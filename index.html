<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MIDI to MakeCode Arcade Song Converter</title>
    <style>
        * { box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            background: #1a1a2e;
            color: #eee;
        }
        h1 { color: #00d9ff; text-align: center; }
        .drop-zone {
            border: 3px dashed #00d9ff;
            border-radius: 12px;
            padding: 40px;
            text-align: center;
            margin: 20px 0;
            background: rgba(0, 217, 255, 0.05);
            transition: all 0.3s;
            cursor: pointer;
        }
        .drop-zone:hover, .drop-zone.dragover {
            background: rgba(0, 217, 255, 0.15);
            border-color: #ff6b6b;
        }
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        .control-group {
            background: #16213e;
            padding: 15px;
            border-radius: 8px;
        }
        label {
            display: block;
            margin-bottom: 8px;
            color: #00d9ff;
            font-weight: 500;
        }
        select, input {
            width: 100%;
            padding: 10px;
            border: none;
            border-radius: 6px;
            background: #0f3460;
            color: #eee;
            font-size: 14px;
        }
        .output-area {
            background: #16213e;
            border-radius: 12px;
            padding: 20px;
            margin: 20px 0;
        }
        .output-label {
            color: #00d9ff;
            margin-bottom: 10px;
            font-weight: 600;
        }
        .hex-output, .code-output {
            background: #0a0a15;
            padding: 15px;
            border-radius: 8px;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 12px;
            word-break: break-all;
            max-height: 200px;
            overflow-y: auto;
            margin-bottom: 15px;
            white-space: pre-wrap;
        }
        .code-output { color: #7dff7d; }
        .hex-output { color: #ffb86c; }
        button {
            background: #00d9ff;
            color: #1a1a2e;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            font-size: 14px;
            transition: all 0.2s;
        }
        button:hover { background: #00b8d9; transform: translateY(-1px); }
        button:active { transform: translateY(0); }
        .btn-group { display: flex; gap: 10px; flex-wrap: wrap; }
        .info-text { color: #888; font-size: 13px; margin-top: 10px; }
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 10px;
            margin: 15px 0;
        }
        .stat {
            background: #0f3460;
            padding: 12px;
            border-radius: 6px;
            text-align: center;
        }
        .stat-value { font-size: 20px; font-weight: bold; color: #00d9ff; }
        .stat-label { font-size: 11px; color: #888; text-transform: uppercase; }
        #file-input { display: none; }
        .hidden { display: none; }
        .error { color: #ff6b6b; background: rgba(255,107,107,0.1); padding: 15px; border-radius: 8px; margin: 10px 0; }
    </style>
</head>
<body>
    <h1>üéµ MIDI ‚Üí MakeCode Arcade</h1>
    
    <div class="drop-zone" id="drop-zone">
        <p>üìÅ Drag & drop a MIDI file here</p>
        <p style="color: #888; font-size: 14px;">or click to select</p>
        <input type="file" id="file-input" accept=".mid,.midi">
    </div>

    <div id="error-box" class="error hidden"></div>

    <div class="controls">
        <div class="control-group">
            <label for="divisor">Tempo Divisor</label>
            <select id="divisor">
                <option value="1">1x (Original)</option>
                <option value="2">2x (Longer songs)</option>
                <option value="4">4x (Much longer)</option>
                <option value="8">8x (Very long)</option>
            </select>
        </div>
        <div class="control-group">
            <label for="octave">Octave</label>
            <select id="octave">
                <option value="auto">Auto-detect</option>
                <option value="4">Octave 4 (Low: C1-D6)</option>
                <option value="5" selected>Octave 5 (Middle C: C2-D7)</option>
                <option value="6">Octave 6 (High: C3-D8)</option>
            </select>
        </div>
        <div class="control-group">
            <label for="condense">Note Range</label>
            <select id="condense">
                <option value="none">Original (no change)</option>
                <option value="4">Condense to 4 octaves (C2-B5)</option>
                <option value="3">Condense to 3 octaves (C3-B5)</option>
                <option value="2">Condense to 2 octaves (C4-B5)</option>
            </select>
        </div>
    </div>

    <div id="output-section" class="hidden">
        <div class="stats" id="stats"></div>
        
        <div class="output-area">
            <div class="output-label">üìù MakeCode TypeScript Code</div>
            <div class="code-output" id="code-output"></div>
            <div class="btn-group">
                <button onclick="copyCode()">üìã Copy Code</button>
                <button onclick="downloadCode()">üíæ Download .ts</button>
            </div>
        </div>

        <div class="output-area">
            <div class="output-label">üî¢ Raw Hex Data</div>
            <div class="hex-output" id="hex-output"></div>
            <div class="btn-group">
                <button onclick="copyHex()">üìã Copy Hex</button>
            </div>
        </div>

        <p class="info-text">
            <strong>How to use:</strong> Copy the TypeScript code and paste it into your MakeCode Arcade project's JavaScript/TypeScript editor.
        </p>
    </div>

    <script>
    // ============================================
    // Simple MIDI Parser (no external dependencies)
    // ============================================
    class MidiParser {
        constructor(arrayBuffer) {
            this.data = new DataView(arrayBuffer);
            this.pos = 0;
        }

        readUint8() {
            return this.data.getUint8(this.pos++);
        }

        readUint16() {
            const val = this.data.getUint16(this.pos);
            this.pos += 2;
            return val;
        }

        readUint32() {
            const val = this.data.getUint32(this.pos);
            this.pos += 4;
            return val;
        }

        readVarInt() {
            let value = 0;
            let byte;
            do {
                byte = this.readUint8();
                value = (value << 7) | (byte & 0x7F);
            } while (byte & 0x80);
            return value;
        }

        readString(length) {
            let str = '';
            for (let i = 0; i < length; i++) {
                str += String.fromCharCode(this.readUint8());
            }
            return str;
        }

        parse() {
            // Read header
            const headerChunk = this.readString(4);
            if (headerChunk !== 'MThd') {
                throw new Error('Invalid MIDI file: missing MThd header');
            }

            const headerLength = this.readUint32();
            const format = this.readUint16();
            const numTracks = this.readUint16();
            const timeDivision = this.readUint16();

            const tracks = [];

            // Read tracks
            for (let t = 0; t < numTracks; t++) {
                const trackChunk = this.readString(4);
                if (trackChunk !== 'MTrk') {
                    throw new Error('Invalid MIDI file: missing MTrk chunk');
                }

                const trackLength = this.readUint32();
                const trackEnd = this.pos + trackLength;
                const events = [];
                let runningStatus = 0;

                while (this.pos < trackEnd) {
                    const deltaTime = this.readVarInt();
                    let status = this.readUint8();

                    // Running status
                    if (status < 0x80) {
                        this.pos--;
                        status = runningStatus;
                    } else {
                        runningStatus = status;
                    }

                    const eventType = status & 0xF0;
                    const channel = status & 0x0F;

                    if (status === 0xFF) {
                        // Meta event
                        const metaType = this.readUint8();
                        const metaLength = this.readVarInt();
                        const metaData = [];
                        for (let i = 0; i < metaLength; i++) {
                            metaData.push(this.readUint8());
                        }
                        events.push({ deltaTime, type: 'meta', metaType, data: metaData });
                    } else if (status === 0xF0 || status === 0xF7) {
                        // SysEx
                        const sysexLength = this.readVarInt();
                        this.pos += sysexLength;
                        events.push({ deltaTime, type: 'sysex' });
                    } else if (eventType === 0x80) {
                        // Note Off
                        const note = this.readUint8();
                        const velocity = this.readUint8();
                        events.push({ deltaTime, type: 'noteOff', channel, note, velocity });
                    } else if (eventType === 0x90) {
                        // Note On
                        const note = this.readUint8();
                        const velocity = this.readUint8();
                        events.push({ deltaTime, type: 'noteOn', channel, note, velocity });
                    } else if (eventType === 0xA0) {
                        // Aftertouch
                        this.pos += 2;
                        events.push({ deltaTime, type: 'aftertouch' });
                    } else if (eventType === 0xB0) {
                        // Control Change
                        this.pos += 2;
                        events.push({ deltaTime, type: 'controlChange' });
                    } else if (eventType === 0xC0) {
                        // Program Change
                        this.pos += 1;
                        events.push({ deltaTime, type: 'programChange' });
                    } else if (eventType === 0xD0) {
                        // Channel Pressure
                        this.pos += 1;
                        events.push({ deltaTime, type: 'channelPressure' });
                    } else if (eventType === 0xE0) {
                        // Pitch Bend
                        this.pos += 2;
                        events.push({ deltaTime, type: 'pitchBend' });
                    } else {
                        // Unknown, try to skip
                        console.warn('Unknown MIDI event:', status.toString(16));
                    }
                }

                tracks.push(events);
            }

            return { format, numTracks, timeDivision, tracks };
        }
    }

    // ============================================
    // MakeCode Song Encoder
    // ============================================
    // Default instrument settings (piano-like)
    const DEFAULT_INSTRUMENT = { waveShape: 1, octave: 5, attack: 10, decay: 100, sustain: 500, release: 100 };

    function encode16bit(value) {
        return [value & 0xFF, (value >> 8) & 0xFF];
    }

    function encodeInstrument(preset) {
        const data = [];
        
        // Byte 0: Wave shape
        data.push(preset.waveShape || 1);
        
        // Bytes 1-8: Amp envelope times (4 x 16-bit LE)
        data.push(...encode16bit(preset.attack || 500));
        data.push(...encode16bit(preset.decay || 100));
        data.push(...encode16bit(preset.sustain || 255));
        data.push(...encode16bit(preset.release || 500));
        
        // Bytes 9-12: Amp envelope volumes (matching MakeCode default)
        data.push(0, 4, 0, 0);
        
        // Bytes 13-23: Freq envelope data (11 bytes of zeros)
        for (let i = 0; i < 11; i++) data.push(0);
        
        // Byte 24: Octave
        data.push(preset.octave || 5);
        
        // Bytes 25-26: padding
        data.push(0, 0);
        
        // Byte 27: trailing byte (matches MakeCode)
        data.push(4);
        
        return data;  // 28 bytes total
    }

    function encodeNoteEvent(event, octave) {
        const data = [];
        data.push(...encode16bit(event.startTick));
        data.push(...encode16bit(event.endTick));
        data.push(event.notes.length);
        
        // Formula: stored = MIDI - (octave-2)*12 + 1
        // This is 1-indexed (C = 1, not 0)
        const octaveOffset = (octave - 2) * 12;
        for (const note of event.notes) {
            const adjustedNote = (note - octaveOffset + 1) & 0x3F;
            data.push(adjustedNote); // Just the note, no enharmonic byte!
        }
        return data;
    }

    function encodeTrack(track) {
        const data = [];
        data.push(track.id);
        data.push(0x00);  // Extra byte (flags?) - MakeCode format has this
        
        const instData = encodeInstrument(track.instrument);
        data.push(...encode16bit(instData.length));
        data.push(...instData);
        
        // Sort notes by start tick
        track.notes.sort((a, b) => a.startTick - b.startTick);
        
        // Calculate total note bytes for the count field
        let noteBytes = 0;
        for (const note of track.notes) {
            noteBytes += 5 + note.notes.length; // 2+2+1 + notes
        }
        data.push(...encode16bit(noteBytes));
        
        for (const note of track.notes) {
            data.push(...encodeNoteEvent(note, track.instrument.octave));
        }
        return data;
    }

    function encodeSong(song) {
        const data = [];
        data.push(0x00); // version
        data.push(...encode16bit(song.bpm));
        data.push(song.beatsPerMeasure);
        data.push(song.ticksPerBeat);
        data.push(Math.min(song.measures, 255));
        data.push(song.tracks.length);
        
        for (const track of song.tracks) {
            data.push(...encodeTrack(track));
        }
        return data;
    }

    function toHexString(data) {
        return data.map(b => b.toString(16).padStart(2, '0')).join('');
    }

    // Convert MIDI note number to note name (e.g., 60 -> "C4")
    function midiToNoteName(midi) {
        if (midi < 0 || midi > 127) return '?';
        const notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
        const octave = Math.floor(midi / 12) - 1;
        const note = notes[midi % 12];
        return note + octave;
    }

    // Shift a note by octaves until it fits within the target range
    function condenseNote(note, minNote, maxNote) {
        while (note < minNote) {
            note += 12;
        }
        while (note > maxNote) {
            note -= 12;
        }
        return note;
    }

    function midiToSong(midiData, divisor, octaveOverride, condenseRange) {
        const preset = { ...DEFAULT_INSTRUMENT };
        const ticksPerBeat = midiData.timeDivision || 480;
        const mcTicksPerBeat = 8;
        
        let bpm = 120;
        let totalTicks = 0;
        const noteEvents = [];
        const activeNotes = {};
        
        // Process all tracks
        for (let trackIdx = 0; trackIdx < midiData.tracks.length; trackIdx++) {
            const track = midiData.tracks[trackIdx];
            let currentTick = 0;
            
            for (const event of track) {
                currentTick += event.deltaTime || 0;
                
                // Tempo meta event (type 0x51)
                if (event.type === 'meta' && event.metaType === 0x51 && event.data.length >= 3) {
                    const tempo = (event.data[0] << 16) | (event.data[1] << 8) | event.data[2];
                    bpm = Math.round(60000000 / tempo);
                }
                
                // Note on
                if (event.type === 'noteOn' && event.velocity > 0) {
                    const note = event.note;
                    const mcTick = Math.floor((currentTick / ticksPerBeat) * mcTicksPerBeat / divisor);
                    activeNotes[`${trackIdx}-${note}`] = mcTick;
                }
                
                // Note off
                if (event.type === 'noteOff' || (event.type === 'noteOn' && event.velocity === 0)) {
                    const note = event.note;
                    const key = `${trackIdx}-${note}`;
                    if (activeNotes[key] !== undefined) {
                        const startTick = activeNotes[key];
                        const mcTick = Math.floor((currentTick / ticksPerBeat) * mcTicksPerBeat / divisor);
                        delete activeNotes[key];
                        
                        if (mcTick > startTick) {
                            // Apply note range condensing if enabled
                            let finalNote = note;
                            if (condenseRange !== 'none') {
                                const octaves = parseInt(condenseRange);
                                // Define ranges centered around middle C (60)
                                // 4 octaves: C2(36) to B5(83)
                                // 3 octaves: C3(48) to B5(83)  
                                // 2 octaves: C4(60) to B5(83)
                                const ranges = {
                                    4: { min: 36, max: 83 },  // C2 to B5
                                    3: { min: 48, max: 83 },  // C3 to B5
                                    2: { min: 60, max: 83 }   // C4 to B5
                                };
                                const range = ranges[octaves];
                                finalNote = condenseNote(note, range.min, range.max);
                            }
                            
                            noteEvents.push({
                                notes: [finalNote],
                                startTick,
                                endTick: mcTick
                            });
                        }
                    }
                }
                
                totalTicks = Math.max(totalTicks, currentTick);
            }
        }
        
        // Calculate measures
        const totalBeats = (totalTicks / ticksPerBeat) / divisor;
        const measures = Math.min(Math.ceil(totalBeats / 4) + 1, 255);
        
        // Determine octave
        let octave = preset.octave;
        if (octaveOverride && octaveOverride !== 'auto') {
            octave = parseInt(octaveOverride);
        } else if (noteEvents.length > 0) {
            const allNotes = noteEvents.flatMap(e => e.notes);
            const minNote = Math.min(...allNotes);
            const maxNote = Math.max(...allNotes);
            const avgNote = allNotes.reduce((a, b) => a + b, 0) / allNotes.length;
            
            // For octave O, valid MIDI range is (O-2)*12+1 to (O-2)*12+63
            // Octave 5 covers MIDI 36-98 (C2 to D7) - good for most music
            // Octave 4 covers MIDI 24-86 (C1 to D6) - lower range
            // Octave 6 covers MIDI 48-110 (C3 to D8) - higher range
            
            // Pick octave that best centers the note range
            if (avgNote < 48) {
                octave = 4;  // Low notes
            } else if (avgNote > 84) {
                octave = 6;  // High notes
            } else {
                octave = 5;  // Middle C range (default)
            }
        }
        
        preset.octave = octave;
        
        // Calculate note range for stats
        let minNote = 127, maxNote = 0;
        if (noteEvents.length > 0) {
            for (const ev of noteEvents) {
                for (const n of ev.notes) {
                    minNote = Math.min(minNote, n);
                    maxNote = Math.max(maxNote, n);
                }
            }
        }
        
        return {
            bpm: Math.min(Math.max(bpm, 20), 500),
            beatsPerMeasure: 4,
            ticksPerBeat: mcTicksPerBeat,
            measures,
            tracks: [{
                id: 0,
                instrument: preset,
                notes: noteEvents
            }],
            stats: {
                bpm: Math.min(Math.max(bpm, 20), 500),
                measures,
                noteCount: noteEvents.length,
                octave,
                minNote,
                maxNote
            }
        };
    }

    // ============================================
    // UI Logic
    // ============================================
    const dropZone = document.getElementById('drop-zone');
    const fileInput = document.getElementById('file-input');
    const outputSection = document.getElementById('output-section');
    const errorBox = document.getElementById('error-box');
    
    let currentHex = '';
    let currentCode = '';
    let lastMidiData = null;
    let lastFileName = '';

    function showError(msg) {
        errorBox.textContent = '‚ùå ' + msg;
        errorBox.classList.remove('hidden');
    }

    function hideError() {
        errorBox.classList.add('hidden');
    }

    dropZone.addEventListener('click', () => fileInput.click());
    
    dropZone.addEventListener('dragover', (e) => {
        e.preventDefault();
        dropZone.classList.add('dragover');
    });
    
    dropZone.addEventListener('dragleave', () => {
        dropZone.classList.remove('dragover');
    });
    
    dropZone.addEventListener('drop', (e) => {
        e.preventDefault();
        dropZone.classList.remove('dragover');
        const file = e.dataTransfer.files[0];
        if (file) processFile(file);
    });
    
    fileInput.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (file) processFile(file);
    });

    function processFile(file) {
        hideError();
        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const parser = new MidiParser(e.target.result);
                lastMidiData = parser.parse();
                lastFileName = file.name;
                convertMidi();
            } catch (err) {
                showError('Error parsing MIDI file: ' + err.message);
                console.error(err);
            }
        };
        reader.onerror = () => {
            showError('Error reading file');
        };
        reader.readAsArrayBuffer(file);
    }

    function convertMidi() {
        if (!lastMidiData) return;
        
        try {
            const divisor = parseInt(document.getElementById('divisor').value);
            const octave = document.getElementById('octave').value;
            const condense = document.getElementById('condense').value;
            
            const song = midiToSong(lastMidiData, divisor, octave, condense);
            const encoded = encodeSong(song);
            currentHex = toHexString(encoded);
            currentCode = `music.play(music.createSong(hex\`${currentHex}\`), music.PlaybackMode.UntilDone)`;
            
            // Update UI
            document.getElementById('hex-output').textContent = currentHex;
            document.getElementById('code-output').textContent = currentCode;
            
            document.getElementById('stats').innerHTML = `
                <div class="stat"><div class="stat-value">${song.stats.bpm}</div><div class="stat-label">BPM</div></div>
                <div class="stat"><div class="stat-value">${song.stats.measures}</div><div class="stat-label">Measures</div></div>
                <div class="stat"><div class="stat-value">${song.stats.noteCount}</div><div class="stat-label">Notes</div></div>
                <div class="stat"><div class="stat-value">${song.stats.octave}</div><div class="stat-label">Octave</div></div>
                <div class="stat"><div class="stat-value">${midiToNoteName(song.stats.minNote)}-${midiToNoteName(song.stats.maxNote)}</div><div class="stat-label">Range</div></div>
                <div class="stat"><div class="stat-value">${currentHex.length}</div><div class="stat-label">Hex Chars</div></div>
            `;
            
            outputSection.classList.remove('hidden');
            dropZone.innerHTML = `<p>‚úÖ Converted: ${lastFileName}</p><p style="color: #888; font-size: 14px;">Drop another file to convert</p>`;
            hideError();
        } catch (err) {
            showError('Error converting MIDI: ' + err.message);
            console.error(err);
        }
    }

    // Re-convert when options change
    document.getElementById('divisor').addEventListener('change', convertMidi);
    document.getElementById('octave').addEventListener('change', convertMidi);
    document.getElementById('condense').addEventListener('change', convertMidi);

    function copyCode() {
        navigator.clipboard.writeText(currentCode).then(() => {
            alert('Code copied to clipboard!');
        }).catch(() => {
            // Fallback
            const ta = document.createElement('textarea');
            ta.value = currentCode;
            document.body.appendChild(ta);
            ta.select();
            document.execCommand('copy');
            document.body.removeChild(ta);
            alert('Code copied to clipboard!');
        });
    }

    function copyHex() {
        navigator.clipboard.writeText(currentHex).then(() => {
            alert('Hex copied to clipboard!');
        }).catch(() => {
            const ta = document.createElement('textarea');
            ta.value = currentHex;
            document.body.appendChild(ta);
            ta.select();
            document.execCommand('copy');
            document.body.removeChild(ta);
            alert('Hex copied to clipboard!');
        });
    }

    function downloadCode() {
        const blob = new Blob([currentCode], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'song.ts';
        a.click();
        URL.revokeObjectURL(url);
    }
    </script>
</body>
</html>
