<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MIDI to MakeCode Arcade Song Converter v1.1</title>
    <style>
        * { box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            background: #1a1a2e;
            color: #eee;
        }
        h1 { color: #00d9ff; text-align: center; }
        h2 { color: #00d9ff; font-size: 16px; margin: 0 0 10px 0; }
        .drop-zone {
            border: 3px dashed #00d9ff;
            border-radius: 12px;
            padding: 40px;
            text-align: center;
            margin: 20px 0;
            background: rgba(0, 217, 255, 0.05);
            transition: all 0.3s;
            cursor: pointer;
        }
        .drop-zone:hover, .drop-zone.dragover {
            background: rgba(0, 217, 255, 0.15);
            border-color: #ff6b6b;
        }
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        .control-group {
            background: #16213e;
            padding: 15px;
            border-radius: 8px;
        }
        label {
            display: block;
            margin-bottom: 8px;
            color: #00d9ff;
            font-weight: 500;
        }
        select, input[type="number"] {
            width: 100%;
            padding: 10px;
            border: none;
            border-radius: 6px;
            background: #0f3460;
            color: #eee;
            font-size: 14px;
        }
        .output-area {
            background: #16213e;
            border-radius: 12px;
            padding: 20px;
            margin: 20px 0;
        }
        .output-label {
            color: #00d9ff;
            margin-bottom: 10px;
            font-weight: 600;
        }
        .hex-output, .code-output {
            background: #0a0a15;
            padding: 15px;
            border-radius: 8px;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 12px;
            word-break: break-all;
            max-height: 200px;
            overflow-y: auto;
            margin-bottom: 15px;
            white-space: pre-wrap;
        }
        .code-output { color: #7dff7d; }
        .hex-output { color: #ffb86c; }
        button {
            background: #00d9ff;
            color: #1a1a2e;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            font-size: 14px;
            transition: all 0.2s;
        }
        button:hover { background: #00b8d9; transform: translateY(-1px); }
        button:active { transform: translateY(0); }
        button:disabled { background: #555; cursor: not-allowed; transform: none; }
        .btn-group { display: flex; gap: 10px; flex-wrap: wrap; }
        .info-text { color: #888; font-size: 13px; margin-top: 10px; }
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 10px;
            margin: 15px 0;
        }
        .stat {
            background: #0f3460;
            padding: 12px;
            border-radius: 6px;
            text-align: center;
        }
        .stat-value { font-size: 20px; font-weight: bold; color: #00d9ff; }
        .stat-label { font-size: 11px; color: #888; text-transform: uppercase; }
        #file-input { display: none; }
        .hidden { display: none; }
        .error { color: #ff6b6b; background: rgba(255,107,107,0.1); padding: 15px; border-radius: 8px; margin: 10px 0; }
        
        /* New styles for player and track selection */
        .player-section {
            background: #16213e;
            border-radius: 12px;
            padding: 20px;
            margin: 20px 0;
        }
        .player-controls {
            display: flex;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
        }
        .play-btn { background: #4CAF50; }
        .play-btn:hover { background: #45a049; }
        .stop-btn { background: #f44336; }
        .stop-btn:hover { background: #da190b; }
        .progress-bar {
            flex: 1;
            min-width: 200px;
            height: 8px;
            background: #0f3460;
            border-radius: 4px;
            overflow: hidden;
        }
        .progress-fill {
            height: 100%;
            background: #00d9ff;
            width: 0%;
            transition: width 0.1s linear;
        }
        .time-display {
            font-family: monospace;
            color: #888;
            min-width: 100px;
        }
        
        .track-section {
            background: #16213e;
            border-radius: 12px;
            padding: 20px;
            margin: 20px 0;
        }
        .track-list {
            max-height: 300px;
            overflow-y: auto;
        }
        .track-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            background: #0f3460;
            border-radius: 6px;
            margin-bottom: 8px;
        }
        .track-item:hover {
            background: #1a4a7a;
        }
        .track-item input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }
        .track-info {
            flex: 1;
        }
        .track-name {
            font-weight: 600;
            color: #eee;
        }
        .track-details {
            font-size: 12px;
            color: #888;
        }
        .track-preview {
            padding: 6px 12px;
            font-size: 12px;
        }
        .channel-badge {
            display: inline-block;
            background: #00d9ff;
            color: #1a1a2e;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 11px;
            margin-right: 5px;
        }
        .note-range {
            color: #7dff7d;
        }
    </style>
</head>
<body>
    <h1>üéµ MIDI ‚Üí MakeCode Arcade</h1>
    
    <div class="drop-zone" id="drop-zone">
        <p>üìÅ Drag & drop a MIDI file here</p>
        <p style="color: #888; font-size: 14px;">or click to select</p>
        <input type="file" id="file-input" accept=".mid,.midi">
    </div>

    <div id="error-box" class="error hidden"></div>

    <!-- MIDI Player Section -->
    <div id="player-section" class="player-section hidden">
        <h2>üéß Preview MIDI</h2>
        <div class="player-controls">
            <button id="play-btn" class="play-btn" onclick="togglePlayback()">‚ñ∂ Play</button>
            <button id="stop-btn" class="stop-btn" onclick="stopPlayback()">‚ñ† Stop</button>
            <div class="progress-bar">
                <div class="progress-fill" id="progress-fill"></div>
            </div>
            <span class="time-display" id="time-display">0:00 / 0:00</span>
        </div>
    </div>

    <!-- Track Selection Section -->
    <div id="track-section" class="track-section hidden">
        <h2>üéº Select Tracks/Channels</h2>
        <p class="info-text">Choose which tracks to include in the conversion. Uncheck tracks to isolate melodies.</p>
        <div class="btn-group" style="margin: 10px 0;">
            <button onclick="selectAllTracks()">Select All</button>
            <button onclick="selectNoTracks()">Select None</button>
        </div>
        <div class="track-list" id="track-list"></div>
    </div>

    <div class="controls">
        <div class="control-group">
            <label for="divisor">Tempo Divisor</label>
            <select id="divisor">
                <option value="1">1x (Original)</option>
                <option value="2">2x (Longer songs)</option>
                <option value="4">4x (Much longer)</option>
                <option value="8">8x (Very long)</option>
            </select>
        </div>
        <div class="control-group">
            <label for="octave">Octave</label>
            <select id="octave">
                <option value="auto">Auto-detect</option>
                <option value="4">Octave 4 (Low: C1-D6)</option>
                <option value="5" selected>Octave 5 (Middle C: C2-D7)</option>
                <option value="6">Octave 6 (High: C3-D8)</option>
            </select>
        </div>
        <div class="control-group">
            <label for="condense">Note Range</label>
            <select id="condense">
                <option value="none">Original (no change)</option>
                <option value="4">Condense to 4 octaves (C2-B5)</option>
                <option value="3">Condense to 3 octaves (C3-B5)</option>
                <option value="2">Condense to 2 octaves (C4-B5)</option>
            </select>
        </div>
    </div>

    <div id="output-section" class="hidden">
        <div class="stats" id="stats"></div>
        
        <div class="output-area">
            <div class="output-label">üìù MakeCode TypeScript Code</div>
            <div class="code-output" id="code-output"></div>
            <div class="btn-group">
                <button onclick="copyCode()">üìã Copy Code</button>
                <button onclick="downloadCode()">üíæ Download .ts</button>
            </div>
        </div>

        <div class="output-area">
            <div class="output-label">üî¢ Raw Hex Data</div>
            <div class="hex-output" id="hex-output"></div>
            <div class="btn-group">
                <button onclick="copyHex()">üìã Copy Hex</button>
            </div>
        </div>

        <p class="info-text">
            <strong>How to use:</strong> Copy the TypeScript code and paste it into your MakeCode Arcade project's JavaScript/TypeScript editor.
        </p>
    </div>

    <script>
    // ============================================
    // Simple MIDI Parser
    // ============================================
    class MidiParser {
        constructor(arrayBuffer) {
            this.data = new DataView(arrayBuffer);
            this.pos = 0;
        }

        readUint8() {
            return this.data.getUint8(this.pos++);
        }

        readUint16() {
            const val = this.data.getUint16(this.pos);
            this.pos += 2;
            return val;
        }

        readUint32() {
            const val = this.data.getUint32(this.pos);
            this.pos += 4;
            return val;
        }

        readVarInt() {
            let value = 0;
            let byte;
            do {
                byte = this.readUint8();
                value = (value << 7) | (byte & 0x7F);
            } while (byte & 0x80);
            return value;
        }

        readString(length) {
            let str = '';
            for (let i = 0; i < length; i++) {
                str += String.fromCharCode(this.readUint8());
            }
            return str;
        }

        parse() {
            const headerChunk = this.readString(4);
            if (headerChunk !== 'MThd') {
                throw new Error('Invalid MIDI file: missing MThd header');
            }

            const headerLength = this.readUint32();
            const format = this.readUint16();
            const numTracks = this.readUint16();
            const timeDivision = this.readUint16();

            const tracks = [];

            for (let t = 0; t < numTracks; t++) {
                const trackChunk = this.readString(4);
                if (trackChunk !== 'MTrk') {
                    throw new Error('Invalid MIDI file: missing MTrk chunk');
                }

                const trackLength = this.readUint32();
                const trackEnd = this.pos + trackLength;
                const events = [];
                let runningStatus = 0;
                let trackName = `Track ${t + 1}`;

                while (this.pos < trackEnd) {
                    const deltaTime = this.readVarInt();
                    let status = this.readUint8();

                    if (status < 0x80) {
                        this.pos--;
                        status = runningStatus;
                    } else {
                        runningStatus = status;
                    }

                    const eventType = status & 0xF0;
                    const channel = status & 0x0F;

                    if (status === 0xFF) {
                        const metaType = this.readUint8();
                        const metaLength = this.readVarInt();
                        const metaData = [];
                        for (let i = 0; i < metaLength; i++) {
                            metaData.push(this.readUint8());
                        }
                        // Track name (meta type 0x03)
                        if (metaType === 0x03) {
                            trackName = String.fromCharCode(...metaData);
                        }
                        events.push({ deltaTime, type: 'meta', metaType, data: metaData });
                    } else if (status === 0xF0 || status === 0xF7) {
                        const sysexLength = this.readVarInt();
                        this.pos += sysexLength;
                        events.push({ deltaTime, type: 'sysex' });
                    } else if (eventType === 0x80) {
                        const note = this.readUint8();
                        const velocity = this.readUint8();
                        events.push({ deltaTime, type: 'noteOff', channel, note, velocity });
                    } else if (eventType === 0x90) {
                        const note = this.readUint8();
                        const velocity = this.readUint8();
                        events.push({ deltaTime, type: 'noteOn', channel, note, velocity });
                    } else if (eventType === 0xA0) {
                        this.pos += 2;
                        events.push({ deltaTime, type: 'aftertouch' });
                    } else if (eventType === 0xB0) {
                        this.pos += 2;
                        events.push({ deltaTime, type: 'controlChange' });
                    } else if (eventType === 0xC0) {
                        const program = this.readUint8();
                        events.push({ deltaTime, type: 'programChange', channel, program });
                    } else if (eventType === 0xD0) {
                        this.pos += 1;
                        events.push({ deltaTime, type: 'channelPressure' });
                    } else if (eventType === 0xE0) {
                        this.pos += 2;
                        events.push({ deltaTime, type: 'pitchBend' });
                    }
                }

                tracks.push({ events, name: trackName, index: t });
            }

            return { format, numTracks, timeDivision, tracks };
        }
    }

    // ============================================
    // MIDI Player using Web Audio API
    // ============================================
    let audioContext = null;
    let isPlaying = false;
    let playbackTimeout = null;
    let scheduledNotes = [];
    let playbackStartTime = 0;
    let totalDuration = 0;
    let progressInterval = null;

    function initAudio() {
        if (!audioContext) {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }
        if (audioContext.state === 'suspended') {
            audioContext.resume();
        }
    }

    function midiToFreq(midi) {
        return 440 * Math.pow(2, (midi - 69) / 12);
    }

    function playNote(freq, startTime, duration, velocity = 100) {
        const osc = audioContext.createOscillator();
        const gain = audioContext.createGain();
        
        osc.type = 'triangle';
        osc.frequency.value = freq;
        
        const vol = (velocity / 127) * 0.3;
        gain.gain.setValueAtTime(0, startTime);
        gain.gain.linearRampToValueAtTime(vol, startTime + 0.01);
        gain.gain.linearRampToValueAtTime(vol * 0.7, startTime + duration * 0.7);
        gain.gain.linearRampToValueAtTime(0, startTime + duration);
        
        osc.connect(gain);
        gain.connect(audioContext.destination);
        
        osc.start(startTime);
        osc.stop(startTime + duration + 0.1);
        
        scheduledNotes.push({ osc, gain });
    }

    function togglePlayback() {
        if (isPlaying) {
            pausePlayback();
        } else {
            startPlayback();
        }
    }

    function startPlayback() {
        if (!lastMidiData) return;
        
        initAudio();
        stopPlayback();
        
        isPlaying = true;
        document.getElementById('play-btn').textContent = '‚è∏ Pause';
        
        const ticksPerBeat = lastMidiData.timeDivision || 480;
        let bpm = 120;
        
        // Find tempo
        for (const track of lastMidiData.tracks) {
            for (const event of track.events) {
                if (event.type === 'meta' && event.metaType === 0x51 && event.data.length >= 3) {
                    const tempo = (event.data[0] << 16) | (event.data[1] << 8) | event.data[2];
                    bpm = Math.round(60000000 / tempo);
                    break;
                }
            }
        }
        
        const secondsPerTick = 60 / (bpm * ticksPerBeat);
        playbackStartTime = audioContext.currentTime;
        
        // Get selected tracks
        const selectedTracks = getSelectedTracks();
        
        // Schedule all notes
        let maxTime = 0;
        for (const trackInfo of selectedTracks) {
            const track = lastMidiData.tracks[trackInfo.trackIndex];
            let currentTick = 0;
            const activeNotes = {};
            
            for (const event of track.events) {
                currentTick += event.deltaTime || 0;
                const time = currentTick * secondsPerTick;
                
                if (event.type === 'noteOn' && event.velocity > 0) {
                    if (trackInfo.channels.includes(event.channel)) {
                        activeNotes[event.note] = { time, velocity: event.velocity };
                    }
                } else if (event.type === 'noteOff' || (event.type === 'noteOn' && event.velocity === 0)) {
                    if (activeNotes[event.note]) {
                        const start = activeNotes[event.note];
                        const duration = Math.max(0.05, time - start.time);
                        playNote(midiToFreq(event.note), playbackStartTime + start.time, duration, start.velocity);
                        delete activeNotes[event.note];
                        maxTime = Math.max(maxTime, time);
                    }
                }
            }
        }
        
        totalDuration = maxTime;
        
        // Update progress bar
        progressInterval = setInterval(updateProgress, 100);
        
        // Auto-stop at end
        playbackTimeout = setTimeout(() => {
            stopPlayback();
        }, (totalDuration + 0.5) * 1000);
    }

    function pausePlayback() {
        isPlaying = false;
        document.getElementById('play-btn').textContent = '‚ñ∂ Play';
        clearInterval(progressInterval);
        // Note: Web Audio doesn't easily support pause, so we just stop
        stopPlayback();
    }

    function stopPlayback() {
        isPlaying = false;
        document.getElementById('play-btn').textContent = '‚ñ∂ Play';
        
        clearTimeout(playbackTimeout);
        clearInterval(progressInterval);
        
        // Stop all scheduled oscillators
        for (const note of scheduledNotes) {
            try {
                note.osc.stop();
            } catch (e) {}
        }
        scheduledNotes = [];
        
        document.getElementById('progress-fill').style.width = '0%';
        updateTimeDisplay(0, totalDuration);
    }

    function updateProgress() {
        if (!isPlaying || !audioContext) return;
        const elapsed = audioContext.currentTime - playbackStartTime;
        const percent = Math.min(100, (elapsed / totalDuration) * 100);
        document.getElementById('progress-fill').style.width = percent + '%';
        updateTimeDisplay(elapsed, totalDuration);
    }

    function updateTimeDisplay(current, total) {
        const formatTime = (s) => {
            const mins = Math.floor(s / 60);
            const secs = Math.floor(s % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        };
        document.getElementById('time-display').textContent = `${formatTime(current)} / ${formatTime(total)}`;
    }

    // ============================================
    // Track Analysis & Selection
    // ============================================
    let trackChannelMap = [];  // [{trackIndex, channels: [0,1,...], name, noteCount, minNote, maxNote}]

    function analyzeTrackChannels(midiData) {
        trackChannelMap = [];
        
        for (let t = 0; t < midiData.tracks.length; t++) {
            const track = midiData.tracks[t];
            const channelsInTrack = new Map(); // channel -> {noteCount, minNote, maxNote}
            
            for (const event of track.events) {
                if (event.type === 'noteOn' && event.velocity > 0) {
                    const ch = event.channel;
                    if (!channelsInTrack.has(ch)) {
                        channelsInTrack.set(ch, { noteCount: 0, minNote: 127, maxNote: 0 });
                    }
                    const info = channelsInTrack.get(ch);
                    info.noteCount++;
                    info.minNote = Math.min(info.minNote, event.note);
                    info.maxNote = Math.max(info.maxNote, event.note);
                }
            }
            
            // Create entries for each channel found
            for (const [channel, info] of channelsInTrack) {
                if (info.noteCount > 0) {
                    trackChannelMap.push({
                        trackIndex: t,
                        channel: channel,
                        channels: [channel],
                        name: track.name || `Track ${t + 1}`,
                        noteCount: info.noteCount,
                        minNote: info.minNote,
                        maxNote: info.maxNote
                    });
                }
            }
        }
        
        return trackChannelMap;
    }

    function midiNoteToName(midi) {
        const notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
        const octave = Math.floor(midi / 12) - 1;
        return notes[midi % 12] + octave;
    }

    function renderTrackList() {
        const container = document.getElementById('track-list');
        container.innerHTML = '';
        
        if (trackChannelMap.length === 0) {
            container.innerHTML = '<p style="color: #888;">No note data found in MIDI file.</p>';
            return;
        }
        
        for (let i = 0; i < trackChannelMap.length; i++) {
            const tc = trackChannelMap[i];
            const div = document.createElement('div');
            div.className = 'track-item';
            div.innerHTML = `
                <input type="checkbox" id="track-${i}" checked onchange="convertMidi()">
                <div class="track-info">
                    <div class="track-name">${tc.name}</div>
                    <div class="track-details">
                        <span class="channel-badge">Ch ${tc.channel + 1}</span>
                        <span>${tc.noteCount} notes</span> ¬∑ 
                        <span class="note-range">${midiNoteToName(tc.minNote)} - ${midiNoteToName(tc.maxNote)}</span>
                    </div>
                </div>
                <button class="track-preview" onclick="previewTrack(${i})">‚ñ∂ Preview</button>
            `;
            container.appendChild(div);
        }
    }

    function getSelectedTracks() {
        const selected = [];
        for (let i = 0; i < trackChannelMap.length; i++) {
            const checkbox = document.getElementById(`track-${i}`);
            if (checkbox && checkbox.checked) {
                selected.push(trackChannelMap[i]);
            }
        }
        return selected;
    }

    function selectAllTracks() {
        for (let i = 0; i < trackChannelMap.length; i++) {
            const checkbox = document.getElementById(`track-${i}`);
            if (checkbox) checkbox.checked = true;
        }
        convertMidi();
    }

    function selectNoTracks() {
        for (let i = 0; i < trackChannelMap.length; i++) {
            const checkbox = document.getElementById(`track-${i}`);
            if (checkbox) checkbox.checked = false;
        }
        convertMidi();
    }

    function previewTrack(index) {
        if (!lastMidiData) return;
        
        initAudio();
        stopPlayback();
        
        const tc = trackChannelMap[index];
        const track = lastMidiData.tracks[tc.trackIndex];
        const ticksPerBeat = lastMidiData.timeDivision || 480;
        
        // Find tempo
        let bpm = 120;
        for (const t of lastMidiData.tracks) {
            for (const event of t.events) {
                if (event.type === 'meta' && event.metaType === 0x51 && event.data.length >= 3) {
                    const tempo = (event.data[0] << 16) | (event.data[1] << 8) | event.data[2];
                    bpm = Math.round(60000000 / tempo);
                    break;
                }
            }
        }
        
        const secondsPerTick = 60 / (bpm * ticksPerBeat);
        const startTime = audioContext.currentTime;
        
        let currentTick = 0;
        const activeNotes = {};
        let maxTime = 0;
        
        for (const event of track.events) {
            currentTick += event.deltaTime || 0;
            const time = currentTick * secondsPerTick;
            
            // Limit preview to 10 seconds
            if (time > 10) break;
            
            if (event.type === 'noteOn' && event.velocity > 0 && event.channel === tc.channel) {
                activeNotes[event.note] = { time, velocity: event.velocity };
            } else if ((event.type === 'noteOff' || (event.type === 'noteOn' && event.velocity === 0)) && event.channel === tc.channel) {
                if (activeNotes[event.note]) {
                    const start = activeNotes[event.note];
                    const duration = Math.max(0.05, time - start.time);
                    playNote(midiToFreq(event.note), startTime + start.time, duration, start.velocity);
                    delete activeNotes[event.note];
                    maxTime = Math.max(maxTime, time);
                }
            }
        }
        
        isPlaying = true;
        document.getElementById('play-btn').textContent = '‚è∏ Pause';
        totalDuration = Math.min(maxTime, 10);
        playbackStartTime = startTime;
        progressInterval = setInterval(updateProgress, 100);
        
        playbackTimeout = setTimeout(() => {
            stopPlayback();
        }, (totalDuration + 0.5) * 1000);
    }

    // ============================================
    // MakeCode Song Encoder
    // ============================================
    const DEFAULT_INSTRUMENT = { waveShape: 1, octave: 5, attack: 10, decay: 100, sustain: 500, release: 100 };

    function encode16bit(value) {
        return [value & 0xFF, (value >> 8) & 0xFF];
    }

    function encodeInstrument(preset) {
        const data = [];
        data.push(preset.waveShape || 1);
        data.push(...encode16bit(preset.attack || 500));
        data.push(...encode16bit(preset.decay || 100));
        data.push(...encode16bit(preset.sustain || 255));
        data.push(...encode16bit(preset.release || 500));
        data.push(0, 4, 0, 0);
        for (let i = 0; i < 11; i++) data.push(0);
        data.push(preset.octave || 5);
        data.push(0, 0);
        data.push(4);
        return data;
    }

    function encodeNoteEvent(event, octave) {
        const data = [];
        data.push(...encode16bit(event.startTick));
        data.push(...encode16bit(event.endTick));
        data.push(event.notes.length);
        const octaveOffset = (octave - 2) * 12;
        for (const note of event.notes) {
            const adjustedNote = (note - octaveOffset + 1) & 0x3F;
            data.push(adjustedNote);
        }
        return data;
    }

    function encodeTrack(track) {
        const data = [];
        data.push(track.id);
        data.push(0x00);
        const instData = encodeInstrument(track.instrument);
        data.push(...encode16bit(instData.length));
        data.push(...instData);
        track.notes.sort((a, b) => a.startTick - b.startTick);
        let noteBytes = 0;
        for (const note of track.notes) {
            noteBytes += 5 + note.notes.length;
        }
        data.push(...encode16bit(noteBytes));
        for (const note of track.notes) {
            data.push(...encodeNoteEvent(note, track.instrument.octave));
        }
        return data;
    }

    function encodeSong(song) {
        const data = [];
        data.push(0x00);
        data.push(...encode16bit(song.bpm));
        data.push(song.beatsPerMeasure);
        data.push(song.ticksPerBeat);
        data.push(Math.min(song.measures, 255));
        data.push(song.tracks.length);
        for (const track of song.tracks) {
            data.push(...encodeTrack(track));
        }
        return data;
    }

    function toHexString(data) {
        return data.map(b => b.toString(16).padStart(2, '0')).join('');
    }

    function midiToNoteName(midi) {
        if (midi < 0 || midi > 127) return '?';
        const notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
        const octave = Math.floor(midi / 12) - 1;
        const note = notes[midi % 12];
        return note + octave;
    }

    function condenseNote(note, minNote, maxNote) {
        while (note < minNote) note += 12;
        while (note > maxNote) note -= 12;
        return note;
    }

    function midiToSong(midiData, divisor, octaveOverride, condenseRange, selectedTracks) {
        const preset = { ...DEFAULT_INSTRUMENT };
        const ticksPerBeat = midiData.timeDivision || 480;
        const mcTicksPerBeat = 8;
        
        let bpm = 120;
        let totalTicks = 0;
        const noteEvents = [];
        const activeNotes = {};
        
        // Process only selected tracks/channels
        for (const tc of selectedTracks) {
            const track = midiData.tracks[tc.trackIndex];
            let currentTick = 0;
            
            for (const event of track.events) {
                currentTick += event.deltaTime || 0;
                
                if (event.type === 'meta' && event.metaType === 0x51 && event.data.length >= 3) {
                    const tempo = (event.data[0] << 16) | (event.data[1] << 8) | event.data[2];
                    bpm = Math.round(60000000 / tempo);
                }
                
                if (event.type === 'noteOn' && event.velocity > 0 && tc.channels.includes(event.channel)) {
                    const note = event.note;
                    const mcTick = Math.floor((currentTick / ticksPerBeat) * mcTicksPerBeat / divisor);
                    activeNotes[`${tc.trackIndex}-${tc.channel}-${note}`] = mcTick;
                }
                
                if ((event.type === 'noteOff' || (event.type === 'noteOn' && event.velocity === 0)) && tc.channels.includes(event.channel)) {
                    const note = event.note;
                    const key = `${tc.trackIndex}-${tc.channel}-${note}`;
                    if (activeNotes[key] !== undefined) {
                        const startTick = activeNotes[key];
                        const mcTick = Math.floor((currentTick / ticksPerBeat) * mcTicksPerBeat / divisor);
                        delete activeNotes[key];
                        
                        if (mcTick > startTick) {
                            let finalNote = note;
                            if (condenseRange !== 'none') {
                                const octaves = parseInt(condenseRange);
                                const ranges = {
                                    4: { min: 36, max: 83 },
                                    3: { min: 48, max: 83 },
                                    2: { min: 60, max: 83 }
                                };
                                const range = ranges[octaves];
                                finalNote = condenseNote(note, range.min, range.max);
                            }
                            
                            noteEvents.push({
                                notes: [finalNote],
                                startTick,
                                endTick: mcTick
                            });
                        }
                    }
                }
                
                totalTicks = Math.max(totalTicks, currentTick);
            }
        }
        
        const totalBeats = (totalTicks / ticksPerBeat) / divisor;
        const measures = Math.min(Math.ceil(totalBeats / 4) + 1, 255);
        
        let octave = preset.octave;
        if (octaveOverride && octaveOverride !== 'auto') {
            octave = parseInt(octaveOverride);
        } else if (noteEvents.length > 0) {
            const allNotes = noteEvents.flatMap(e => e.notes);
            const minNote = Math.min(...allNotes);
            const maxNote = Math.max(...allNotes);
            const avgNote = allNotes.reduce((a, b) => a + b, 0) / allNotes.length;
            
            if (avgNote < 48) octave = 4;
            else if (avgNote > 84) octave = 6;
            else octave = 5;
        }
        
        preset.octave = octave;
        
        let minNote = 127, maxNote = 0;
        if (noteEvents.length > 0) {
            for (const ev of noteEvents) {
                for (const n of ev.notes) {
                    minNote = Math.min(minNote, n);
                    maxNote = Math.max(maxNote, n);
                }
            }
        }
        
        return {
            bpm: Math.min(Math.max(bpm, 20), 500),
            beatsPerMeasure: 4,
            ticksPerBeat: mcTicksPerBeat,
            measures,
            tracks: [{
                id: 0,
                instrument: preset,
                notes: noteEvents
            }],
            stats: {
                bpm: Math.min(Math.max(bpm, 20), 500),
                measures,
                noteCount: noteEvents.length,
                octave,
                minNote,
                maxNote
            }
        };
    }

    // ============================================
    // UI Logic
    // ============================================
    const dropZone = document.getElementById('drop-zone');
    const fileInput = document.getElementById('file-input');
    const outputSection = document.getElementById('output-section');
    const playerSection = document.getElementById('player-section');
    const trackSection = document.getElementById('track-section');
    const errorBox = document.getElementById('error-box');
    
    let currentHex = '';
    let currentCode = '';
    let lastMidiData = null;
    let lastFileName = '';

    function showError(msg) {
        errorBox.textContent = '‚ùå ' + msg;
        errorBox.classList.remove('hidden');
    }

    function hideError() {
        errorBox.classList.add('hidden');
    }

    dropZone.addEventListener('click', () => fileInput.click());
    
    dropZone.addEventListener('dragover', (e) => {
        e.preventDefault();
        dropZone.classList.add('dragover');
    });
    
    dropZone.addEventListener('dragleave', () => {
        dropZone.classList.remove('dragover');
    });
    
    dropZone.addEventListener('drop', (e) => {
        e.preventDefault();
        dropZone.classList.remove('dragover');
        const file = e.dataTransfer.files[0];
        if (file) processFile(file);
    });
    
    fileInput.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (file) processFile(file);
    });

    function processFile(file) {
        hideError();
        stopPlayback();
        
        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const parser = new MidiParser(e.target.result);
                lastMidiData = parser.parse();
                lastFileName = file.name;
                
                // Analyze tracks
                analyzeTrackChannels(lastMidiData);
                renderTrackList();
                
                // Show player and track sections
                playerSection.classList.remove('hidden');
                trackSection.classList.remove('hidden');
                
                // Calculate total duration for display
                const ticksPerBeat = lastMidiData.timeDivision || 480;
                let maxTicks = 0;
                let bpm = 120;
                for (const track of lastMidiData.tracks) {
                    let ticks = 0;
                    for (const event of track.events) {
                        ticks += event.deltaTime || 0;
                        if (event.type === 'meta' && event.metaType === 0x51 && event.data.length >= 3) {
                            const tempo = (event.data[0] << 16) | (event.data[1] << 8) | event.data[2];
                            bpm = Math.round(60000000 / tempo);
                        }
                    }
                    maxTicks = Math.max(maxTicks, ticks);
                }
                totalDuration = maxTicks * (60 / (bpm * ticksPerBeat));
                updateTimeDisplay(0, totalDuration);
                
                convertMidi();
            } catch (err) {
                showError('Error parsing MIDI file: ' + err.message);
                console.error(err);
            }
        };
        reader.onerror = () => {
            showError('Error reading file');
        };
        reader.readAsArrayBuffer(file);
    }

    function convertMidi() {
        if (!lastMidiData) return;
        
        try {
            const divisor = parseInt(document.getElementById('divisor').value);
            const octave = document.getElementById('octave').value;
            const condense = document.getElementById('condense').value;
            const selectedTracks = getSelectedTracks();
            
            if (selectedTracks.length === 0) {
                document.getElementById('code-output').textContent = '// No tracks selected';
                document.getElementById('hex-output').textContent = '';
                document.getElementById('stats').innerHTML = '<p style="color: #888;">Select at least one track to convert.</p>';
                outputSection.classList.remove('hidden');
                return;
            }
            
            const song = midiToSong(lastMidiData, divisor, octave, condense, selectedTracks);
            const encoded = encodeSong(song);
            currentHex = toHexString(encoded);
            currentCode = `music.play(music.createSong(hex\`${currentHex}\`), music.PlaybackMode.UntilDone)`;
            
            document.getElementById('hex-output').textContent = currentHex;
            document.getElementById('code-output').textContent = currentCode;
            
            document.getElementById('stats').innerHTML = `
                <div class="stat"><div class="stat-value">${song.stats.bpm}</div><div class="stat-label">BPM</div></div>
                <div class="stat"><div class="stat-value">${song.stats.measures}</div><div class="stat-label">Measures</div></div>
                <div class="stat"><div class="stat-value">${song.stats.noteCount}</div><div class="stat-label">Notes</div></div>
                <div class="stat"><div class="stat-value">${song.stats.octave}</div><div class="stat-label">Octave</div></div>
                <div class="stat"><div class="stat-value">${midiToNoteName(song.stats.minNote)}-${midiToNoteName(song.stats.maxNote)}</div><div class="stat-label">Range</div></div>
                <div class="stat"><div class="stat-value">${currentHex.length}</div><div class="stat-label">Hex Chars</div></div>
            `;
            
            outputSection.classList.remove('hidden');
            dropZone.innerHTML = `<p>‚úÖ Loaded: ${lastFileName}</p><p style="color: #888; font-size: 14px;">Drop another file to convert</p>`;
            hideError();
        } catch (err) {
            showError('Error converting MIDI: ' + err.message);
            console.error(err);
        }
    }

    // Re-convert when options change
    document.getElementById('divisor').addEventListener('change', convertMidi);
    document.getElementById('octave').addEventListener('change', convertMidi);
    document.getElementById('condense').addEventListener('change', convertMidi);

    function copyCode() {
        navigator.clipboard.writeText(currentCode).then(() => {
            alert('Code copied to clipboard!');
        }).catch(() => {
            const ta = document.createElement('textarea');
            ta.value = currentCode;
            document.body.appendChild(ta);
            ta.select();
            document.execCommand('copy');
            document.body.removeChild(ta);
            alert('Code copied to clipboard!');
        });
    }

    function copyHex() {
        navigator.clipboard.writeText(currentHex).then(() => {
            alert('Hex copied to clipboard!');
        }).catch(() => {
            const ta = document.createElement('textarea');
            ta.value = currentHex;
            document.body.appendChild(ta);
            ta.select();
            document.execCommand('copy');
            document.body.removeChild(ta);
            alert('Hex copied to clipboard!');
        });
    }

    function downloadCode() {
        const blob = new Blob([currentCode], { type: 'text/plain' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'song.ts';
        a.click();
        URL.revokeObjectURL(url);
    }
    </script>
</body>
</html>
